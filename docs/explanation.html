<!-- explanation.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMCL Simulation - Explanation</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS (optional) -->
    <link rel="stylesheet" href="styles.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</head>

<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="index.html">AMCL Simulation</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse justify-content-end" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="explanation.html">Explanation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="simulation.html">Simulation</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Page Header -->
    <header class="bg-light py-5">
        <div class="container text-center">
            <h1 class="display-5">Understanding AMCL</h1>
            <p class="lead">Dive deep into the theory behind Adaptive Monte Carlo Localization.</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container my-5">
        <!-- Explanation Page Content -->

        <!-- Introduction Section -->
        <section class="mb-5">
            <h2>Introduction</h2>
            <p>
                Adaptive Monte Carlo Localization (AMCL) is a probabilistic algorithm used in robotics for estimating a
                robot's position and orientation (collectively known as its <strong>pose</strong>) within a known map.
                The purpose of this project is to demonstrate the principles of AMCL through an interactive simulation
                and to explain how it relates to concepts in probability and statistics.
            </p>
            <p>
                Localization is a fundamental problem in robotics: knowing where the robot is within its environment is
                essential for navigation and task execution. AMCL addresses this problem by using a set of hypotheses
                (called <em>particles</em>) to represent possible robot poses, updating them over time based on movement
                and sensor data.
            </p>
            <p>
                This project not only showcases the implementation of AMCL but also delves into the theoretical
                underpinnings that make it an effective solution for robot localization. By exploring the algorithm, we
                aim to bridge the gap between theoretical concepts in probability and their practical applications in
                robotics.
            </p>
        </section>

        <!-- Theoretical Background Section -->
        <section class="mb-5">
            <h2>Theoretical Background</h2>
            <p>
                To understand AMCL, it's important to have a grasp of several key concepts in probability, statistics,
                and robotics. This section covers the fundamental principles that underpin the algorithm.
            </p>

            <!-- Probability and Random Variables -->
            <h3>Probability and Random Variables</h3>
            <p>
                A <strong>random variable</strong> is a variable whose possible values are numerical outcomes of a
                random phenomenon. In robotics, randomness arises due to uncertainties in motion and sensor
                measurements. Probability distributions describe how likely different outcomes are. The <strong>Gaussian
                    (normal) distribution</strong> is particularly important because many types of noise in measurements
                and motion are modeled as Gaussian distributions.
            </p>

            <!-- Bayes' Theorem -->
            <h3>Bayes' Theorem</h3>
            <p>
                <strong>Bayes' Theorem</strong> provides a mathematical framework for updating the probability estimate
                for a hypothesis as more evidence or information becomes available. It is expressed as:
            </p>
            <div class="text-center">
                <img src="images/bayes_theorem.png" alt="Bayes' Theorem Formula" style="max-width: 100%; height: auto;">
                <!-- If you prefer to write the formula in HTML, you can use MathJax or similar libraries -->
            </div>
            <p>
                In the context of localization, Bayes' Theorem allows us to update our belief about the robot's position
                based on new sensor data.
            </p>

            <!-- Monte Carlo Methods -->
            <h3>Monte Carlo Methods</h3>
            <p>
                <strong>Monte Carlo methods</strong> are a class of computational algorithms that rely on repeated
                random sampling to obtain numerical results. They are used to model phenomena with significant
                uncertainty in inputs, such as the prediction of complex physical and mathematical systems.
            </p>

            <!-- Particle Filters -->
            <h3>Particle Filters</h3>
            <p>
                A <strong>particle filter</strong> is an implementation of a Monte Carlo method used for estimating the
                state of a system that changes over time. In robotics, particle filters are used to represent the
                probability distribution of a robot's pose with a set of particles, each representing a possible state.
            </p>

            <!-- States, Controls, and Observations -->
            <h3>States, Controls, and Observations</h3>
            <p>
                Understanding AMCL requires knowledge of three fundamental components:
            </p>
            <ul>
                <li>
                    <strong>State (\(x_t\)):</strong> The robot's pose at time <em>t</em>, including position and
                    orientation.
                </li>
                <li>
                    <strong>Control (\(u_t\)):</strong> The movement commands given to the robot, such as velocity and
                    rotation.
                </li>
                <li>
                    <strong>Observation (\(z_t\)):</strong> Sensor measurements obtained by the robot at time
                    <em>t</em>, like distance readings from a LIDAR sensor.
                </li>
            </ul>

            <!-- Motion Model -->
            <h3>Motion Model</h3>
            <p>
                The <strong>motion model</strong> describes how the robot's state changes over time in response to
                control inputs. It accounts for uncertainties in motion due to factors like wheel slippage or uneven
                terrain. The motion model is represented probabilistically as:
            </p>
            <div class="text-center">
                <img src="images/motion_model.png" alt="Motion Model Formula" style="max-width: 100%; height: auto;">
            </div>
            <p>
                This represents the probability of being in state \( x_t \) given the previous state \( x_{t-1} \) and
                control \( u_t \).
            </p>

            <!-- Sensor Model -->
            <h3>Sensor Model</h3>
            <p>
                The <strong>sensor model</strong> describes how likely a certain observation is, given a particular
                state. It accounts for uncertainties and noise in sensor measurements. It is represented as:
            </p>
            <div class="text-center">
                <img src="images/sensor_model.png" alt="Sensor Model Formula" style="max-width: 100%; height: auto;">
            </div>
            <p>
                This represents the probability of observing \( z_t \) given the state \( x_t \).
            </p>

            <!-- Belief Representation -->
            <h3>Belief Representation</h3>
            <p>
                The robot's <strong>belief</strong> about its state is represented as a probability distribution over
                all possible states. This distribution is updated over time as the robot moves and receives new sensor
                data.
            </p>
            <p>
                The belief at time \( t \) is denoted as:
            </p>
            <div class="text-center">
                <img src="images/belief_representation.png" alt="Belief Representation Formula"
                    style="max-width: 100%; height: auto;">
            </div>

            <!-- Bayes Filter Algorithm -->
            <h3>Bayes Filter Algorithm</h3>
            <p>
                The <strong>Bayes filter</strong> provides a recursive framework for updating the belief over time. It
                consists of two main steps:
            </p>
            <ol>
                <li>
                    <strong>Prediction:</strong> Update the belief based on the motion model and control input.
                    <div class="text-center">
                        <img src="images/prediction_step.png" alt="Prediction Step Formula"
                            style="max-width: 100%; height: auto;">
                    </div>
                    <p>
                        This step predicts the new state distribution \( \overline{bel}(x_t) \) by integrating over all
                        possible previous states.
                    </p>
                </li>
                <li>
                    <strong>Correction:</strong> Update the belief based on the sensor model and new observations.
                    <div class="text-center">
                        <img src="images/correction_step.png" alt="Correction Step Formula"
                            style="max-width: 100%; height: auto;">
                    </div>
                    <p>
                        Here, \( \eta \) is a normalization factor ensuring that the total probability sums to one. This
                        step refines the predicted belief using the latest sensor data.
                    </p>
                </li>
            </ol>
            <p>
                By repeatedly applying these steps, the robot can continually update its belief about its position in
                the environment.
            </p>
        </section>


        <!-- Monte Carlo Localization Section -->
        <section class="mb-5">
            <h2>Monte Carlo Localization</h2>
            <p>
                Monte Carlo Localization (MCL) is a probabilistic algorithm used for robot localization, where the
                robot's position and orientation (pose) are estimated within a known map. MCL utilizes a set of weighted
                hypotheses, called <em>particles</em>, to represent the robot's possible poses.
            </p>

            <!-- States, Controls, and Observations -->
            <h3>States, Controls, and Observations</h3>
            <p>
                To understand MCL, it's important to define three key components:
            </p>
            <ul>
                <li>
                    <strong>State (\( x_t \)):</strong> The state is the collection of all aspects of the robot (and its
                    environment) that completely describes its future. In MCL, the state is the robot's pose,
                    represented by its position and orientation:
                    \[
                    x_t = (x, y, \theta)
                    \]
                    The environment is typically represented by a fixed map.
                </li>
                <li>
                    <strong>Controls (\( u_t \)):</strong> Controls are the variables that enact the change of state.
                    For MCL, the control data consists of the robot's linear and angular velocities:
                    \[
                    u_t = (v, \omega)
                    \]
                    These controls influence how the robot moves from one state to another.
                </li>
                <li>
                    <strong>Observations (\( z_t \)):</strong> Observations are measurement data that provide
                    information about the current state. In MCL, observations are range data obtained from sensors like
                    LIDAR:
                    \[
                    z_t = \text{LIDAR measurements}
                    \]
                    These observations help the robot refine its belief about its position within the map.
                </li>
            </ul>
            <p>
                The robot operates in discrete time steps \( t_0, t_1, \ldots, t_n \). At each time step, the robot
                updates its state based on controls and observations.
            </p>

            <!-- General Model for Dynamics and Observations -->
            <h3>General Model for Dynamics and Observations</h3>
            <p>
                The MCL algorithm relies on probabilistic models to describe how the state evolves over time and how
                observations are generated:
            </p>
            <ul>
                <li>
                    <strong>State Evolution Model:</strong> The new state \( x_t \) is generated from the previous state
                    \( x_{t-1} \) and the control \( u_t \):
                    \[
                    p(x_t | x_{t-1}, u_t)
                    \]
                    This transition model incorporates the uncertainties in the robot's motion, such as wheel slippage
                    or uneven terrain. It is based on the Markov property, implying that the next state depends only on
                    the current state and control input.
                </li>
                <li>
                    <strong>Observation Model:</strong> The observation \( z_t \) is generated from the current state \(
                    x_t \):
                    \[
                    p(z_t | x_t)
                    \]
                    This model describes the likelihood of receiving a particular observation given the robot's state.
                    It accounts for sensor noise and inaccuracies.
                </li>
            </ul>
            <p>
                These models enable the robot to predict its future state and update its belief based on new
                observations.
            </p>

            <!-- Belief Representation -->
            <h3>Belief Representation</h3>
            <p>
                The robot's <strong>belief</strong> about its state at time \( t \) is represented as a probability
                distribution over all possible states, given all past controls and observations:
            </p>
            <div class="text-center">
                \( bel(x_t) = p(x_t | z_{1:t}, u_{1:t}) \)
            </div>
            <p>
                This belief combines all the information the robot has gathered to describe the probability of being in
                any particular state.
            </p>

            <!-- Bayes Filter Algorithm -->
            <h3>Bayes Filter Algorithm</h3>
            <p>
                The Bayes Filter provides a recursive framework for updating the belief over time. It consists of two
                main steps: <strong>prediction</strong> and <strong>correction</strong>.
            </p>
            <ol>
                <li>
                    <strong>Prediction (Prior Update):</strong>
                    <p>
                        The robot uses the state evolution model to predict its new state based on the previous belief
                        and the control input:
                    </p>
                    <div class="text-center">
                        \( \overline{bel}(x_t) = \int p(x_t | x_{t-1}, u_t) \, bel(x_{t-1}) \, dx_{t-1} \)
                    </div>
                    <p>
                        This step accounts for the uncertainty in the robot's motion, spreading the belief over possible
                        new states.
                    </p>
                </li>
                <li>
                    <strong>Correction (Measurement Update):</strong>
                    <p>
                        The robot refines its belief using the new observation and the observation model:
                    </p>
                    <div class="text-center">
                        \( bel(x_t) = \eta \, p(z_t | x_t) \, \overline{bel}(x_t) \)
                    </div>
                    <p>
                        Here, \( \eta \) is a normalization constant ensuring that the total probability sums to one.
                        This step adjusts the belief by weighing the predicted states according to how well they agree
                        with the actual observation.
                    </p>
                </li>
            </ol>
            <p>
                By repeatedly applying these steps at each time interval, the robot continuously updates its belief
                about its position.
            </p>
            <p>
                The integration in the prediction step and the continuous nature of the state space make exact
                computation infeasible for most real-world applications. This is where the Monte Carlo approach comes
                into play, approximating the belief using a finite set of samples or particles.
            </p>
        </section>

        <!-- Particle Filter Section -->
        <section class="mb-5">
            <h2>Particle Filter (Monte Carlo Localization Algorithm)</h2>
            <p>
                The Particle Filter is a sequential Monte Carlo method used to implement the Bayes Filter for systems
                with non-linear dynamics and non-Gaussian probability distributions. In MCL, the Particle Filter
                approximates the belief \( bel(x_t) \) using a set of weighted particles.
            </p>

            <!-- Particle Representation -->
            <h3>Particle Representation</h3>
            <p>
                A <strong>particle</strong> represents a possible state of the robot and is associated with a weight
                that reflects the likelihood of that state given the observations. The set of particles is denoted as:
            </p>
            <div class="text-center">
                \( \{ x_t^{[i]}, w_t^{[i]} \}_{i=1}^M \)
            </div>
            <p>
                Where:
            </p>
            <ul>
                <li>
                    \( x_t^{[i]} \) is the state (pose) of particle \( i \) at time \( t \).
                </li>
                <li>
                    \( w_t^{[i]} \) is the weight of particle \( i \), representing the importance or likelihood of that
                    particle.
                </li>
                <li>
                    \( M \) is the total number of particles.
                </li>
            </ul>

            <!-- Particle Filter Algorithm -->
            <h3>Particle Filter Algorithm</h3>
            <p>
                The Particle Filter operates recursively through the following steps:
            </p>
            <ol>
                <li>
                    <strong>Initialization:</strong>
                    <p>
                        Sample initial particles \( x_0^{[i]} \) from the initial belief \( bel(x_0) \). If no prior
                        information is available, particles can be uniformly distributed over the state space.
                    </p>
                </li>
                <li>
                    <strong>Prediction (Sampling):</strong>
                    <p>
                        For each particle \( x_{t-1}^{[i]} \), generate a new particle \( x_t^{[i]} \) by sampling from
                        the state evolution model:
                    </p>
                    <div class="text-center">
                        \( x_t^{[i]} \sim p(x_t | x_{t-1}^{[i]}, u_t) \)
                    </div>
                    <p>
                        This step simulates the effect of the control input on each particle, accounting for motion
                        uncertainty.
                    </p>
                </li>
                <li>
                    <strong>Weighting (Importance Sampling):</strong>
                    <p>
                        Update the weight of each particle based on the observation likelihood:
                    </p>
                    <div class="text-center">
                        \( w_t^{[i]} = p(z_t | x_t^{[i]}) \)
                    </div>
                    <p>
                        Particles that are more consistent with the actual observation receive higher weights.
                    </p>
                </li>
                <li>
                    <strong>Normalization:</strong>
                    <p>
                        Normalize the weights of all particles so that they sum to one:
                    </p>
                    <div class="text-center">
                        \( w_t^{[i]} = \frac{w_t^{[i]}}{\sum_{j=1}^M w_t^{[j]}} \)
                    </div>
                </li>
                <li>
                    <strong>Resampling:</strong>
                    <p>
                        Generate a new set of particles by sampling from the current set, with replacement, according to
                        their weights. Particles with higher weights are more likely to be selected multiple times,
                        while particles with low weights may be discarded.
                    </p>
                </li>
            </ol>
            <p>
                The resampling step helps to focus computational resources on the more promising areas of the state
                space but can lead to a loss of diversity among particles, known as <em>sample impoverishment</em>.
            </p>

            <!-- Importance of the Particle Filter -->
            <h3>Importance of the Particle Filter</h3>
            <p>
                The Particle Filter allows for an approximate solution to the Bayes Filter in cases where exact
                solutions are computationally infeasible. By representing the belief with particles, we can handle
                complex, multi-modal probability distributions and non-linear motion and observation models.
            </p>
            <p>
                In the context of robot localization, the Particle Filter enables the robot to maintain and update a
                probabilistic belief about its pose in real-time, even in the presence of uncertainty and noise.
            </p>

            <!-- Incorporating Teacher's Notes -->
            <h3>Incorporating Teacher's Notes</h3>
            <p>
                According to our teacher's notes, the key aspects of the Particle Filter in MCL are:
            </p>
            <ul>
                <li>
                    <strong>State Evolution:</strong> The state \( x_t \) is generated stochastically from the previous
                    state \( x_{t-1} \) and controls \( u_t \) using the transition probability \( p(x_t | x_{t-1}, u_t)
                    \).
                </li>
                <li>
                    <strong>Observation Independence:</strong> Observations \( z_t \) are conditionally independent of
                    past measurements given the current state, expressed as \( p(z_t | x_t) \).
                </li>
                <li>
                    <strong>Belief Update:</strong> The belief \( bel(x_t) \) is the posterior distribution of the
                    state, combining all information from controls and observations.
                </li>
            </ul>
            <p>
                These principles form the foundation of the Particle Filter algorithm and guide its implementation in
                MCL.
            </p>

            <!-- Visualization of the Particle Filter Steps -->
            <h3>Visualization of the Particle Filter Steps</h3>
            <p>
                To better understand how the Particle Filter works, let's visualize the steps:
            </p>
            <ol>
                <li>
                    <strong>Initialization:</strong> Particles are randomly distributed across the map, representing the
                    robot's initial uncertainty about its position.
                </li>
                <li>
                    <strong>Prediction:</strong> As the robot moves, particles are propagated according to the motion
                    model, introducing some spread due to motion noise.
                </li>
                <li>
                    <strong>Weighting:</strong> Each particle's weight is updated based on how well its predicted state
                    explains the new sensor observation.
                </li>
                <li>
                    <strong>Resampling:</strong> Particles are resampled based on their weights, focusing on areas with
                    higher probability.
                </li>
            </ol>
            <p>
                Through repeated iterations, the particles converge around the robot's true pose, allowing for accurate
                localization.
            </p>
        </section>

        <!-- Adaptive Monte Carlo Localization Section -->
        <section class="mb-5">
            <h2>Adaptive Monte Carlo Localization (AMCL)</h2>
            <p>
                While the standard Particle Filter is effective for localization, it can be computationally intensive,
                especially in complex environments. Adaptive Monte Carlo Localization (AMCL) enhances the Particle
                Filter by dynamically adjusting the number of particles based on the robot's uncertainty. This allows
                for efficient use of computational resources while maintaining accurate localization.
            </p>

            <!-- Need for Adaptivity -->
            <h3>Need for Adaptivity</h3>
            <p>
                In scenarios where the robot has high uncertainty about its position (e.g., after being kidnapped or in
                ambiguous environments), more particles are needed to explore the possible states. Conversely, when the
                robot is confident about its position, fewer particles suffice. By adapting the number of particles,
                AMCL optimizes performance and accuracy.
            </p>

            <!-- AMCL Algorithm Enhancements -->
            <h3>AMCL Algorithm Enhancements</h3>
            <p>
                AMCL introduces several enhancements to the standard Particle Filter:
            </p>
            <ul>
                <li>
                    <strong>Dynamic Particle Number Adjustment:</strong> The algorithm adjusts the number of particles
                    in response to the robot's uncertainty, increasing particles when uncertainty is high and reducing
                    them when confidence is high.
                </li>
                <li>
                    <strong>Effective Sample Size (ESS):</strong> AMCL calculates the Effective Sample Size to quantify
                    particle diversity. ESS is given by:
                    \[
                    ESS = \frac{1}{\sum_{i=1}^M \left( w_t^{[i]} \right)^2 }
                    \]
                    A lower ESS indicates that fewer particles effectively represent the belief, prompting resampling or
                    increasing particle count.
                </li>
                <li>
                    <strong>KLD-Sampling:</strong> Kullback-Leibler Divergence (KLD) sampling determines the required
                    number of particles based on the desired accuracy and confidence levels. This statistical approach
                    helps maintain the balance between performance and computational load.
                </li>
            </ul>

            <!-- AMCL Algorithm Steps -->
            <h3>AMCL Algorithm Steps</h3>
            <p>
                The AMCL algorithm follows similar steps to the standard Particle Filter, with modifications to
                incorporate adaptivity:
            </p>
            <ol>
                <li>
                    <strong>Initialization:</strong>
                    <p>
                        Start with an initial set of particles based on prior knowledge. The initial particle count can
                        be set to a reasonable default.
                    </p>
                </li>
                <li>
                    <strong>Prediction:</strong>
                    <p>
                        Propagate each particle according to the motion model, adding randomness to account for motion
                        noise.
                    </p>
                </li>
                <li>
                    <strong>Weighting:</strong>
                    <p>
                        Update particle weights based on the likelihood of the new observations given the particle's
                        state.
                    </p>
                </li>
                <li>
                    <strong>Effective Sample Size Calculation:</strong>
                    <p>
                        Calculate ESS to assess the level of particle degeneracy.
                    </p>
                </li>
                <li>
                    <strong>Adaptive Resampling:</strong>
                    <p>
                        If ESS falls below a predefined threshold, perform resampling. Adjust the number of particles
                        based on uncertainty measures like KLD-sampling.
                    </p>
                </li>
                <li>
                    <strong>Normalization:</strong>
                    <p>
                        Normalize the particle weights to ensure they sum to one.
                    </p>
                </li>
            </ol>

            <!-- Advantages of AMCL -->
            <h3>Advantages of AMCL</h3>
            <p>
                AMCL offers several benefits over the standard Particle Filter:
            </p>
            <ul>
                <li>
                    <strong>Computational Efficiency:</strong> By using more particles only when necessary, AMCL reduces
                    the average computational load.
                </li>
                <li>
                    <strong>Improved Accuracy:</strong> Dynamic adjustment allows the algorithm to allocate resources
                    effectively, maintaining accuracy even in challenging conditions.
                </li>
                <li>
                    <strong>Robustness:</strong> AMCL can better handle sudden changes in the robot's environment or
                    unexpected movements.
                </li>
            </ul>

            <!-- Mathematical Foundation -->
            <h3>Mathematical Foundation</h3>
            <p>
                The adaptivity in AMCL is grounded in statistical measures:
            </p>
            <ul>
                <li>
                    <strong>Effective Sample Size (ESS):</strong> As previously mentioned, ESS quantifies the variance
                    of particle weights. A low ESS indicates that few particles have significant weight, suggesting that
                    resampling is needed to avoid sample impoverishment.
                </li>
                <li>
                    <strong>Kullback-Leibler Divergence (KLD):</strong> KLD measures the difference between the true
                    probability distribution and the particle approximation. AMCL uses KLD to determine the minimum
                    number of particles required to achieve a desired approximation accuracy with a specified confidence
                    level.
                </li>
            </ul>
            <p>
                By integrating these statistical measures, AMCL maintains an optimal balance between performance and
                accuracy.
            </p>
        </section>

        <!-- The Simulation Section -->
        <section class="mb-5">
            <h2>The Simulation</h2>
            <p>
                To demonstrate the principles of AMCL, we developed an interactive simulation using Unity. The
                simulation allows users to observe how the algorithm localizes a robot within a known map, adjusting the
                number of particles dynamically based on uncertainty.
            </p>

            <!-- Simulation Overview -->
            <h3>Simulation Overview</h3>
            <p>
                The simulation features:
            </p>
            <ul>
                <li>
                    <strong>Robot Model:</strong> A robot equipped with simulated sensors (e.g., LIDAR) capable of
                    measuring distances to obstacles.
                </li>
                <li>
                    <strong>Environment Map:</strong> A predefined map representing the environment in which the robot
                    operates.
                </li>
                <li>
                    <strong>Particle Visualization:</strong> Particles are visually represented, showing their positions
                    and orientations.
                </li>
                <li>
                    <strong>Adjustable Parameters:</strong> Users can adjust the number of particles and observe the
                    effects on localization performance.
                </li>
            </ul>

            <!-- Implementation Details -->
            <h3>Implementation Details</h3>
            <p>
                The simulation is implemented using the Unity game engine and C#. Key aspects of the implementation
                include:
            </p>
            <ul>
                <li>
                    <strong>Particle Representation:</strong> Each particle is represented by a lightweight object
                    containing its state (position, orientation) and weight.
                </li>
                <li>
                    <strong>Motion Model:</strong> The robot's movement and particle propagation are simulated with
                    added Gaussian noise to represent motion uncertainty.
                </li>
                <li>
                    <strong>Sensor Model:</strong> Simulated sensor readings are generated, and particle weights are
                    updated based on the likelihood of these readings given the particles' states.
                </li>
                <li>
                    <strong>Adaptive Resampling:</strong> The algorithm adjusts the particle count and performs
                    resampling based on the calculated ESS.
                </li>
            </ul>

            <!-- Interactive Features -->
            <h3>Interactive Features</h3>
            <p>
                Users can interact with the simulation in several ways:
            </p>
            <ul>
                <li>
                    <strong>Particle Count Slider:</strong> Adjust the initial number of particles to see how it affects
                    localization accuracy and computational load.
                </li>
                <li>
                    <strong>Reset Button:</strong> Restart the simulation with new parameters or to observe different
                    scenarios.
                </li>
                <li>
                    <strong>Visualization Controls:</strong> Toggle the display of particles, sensor rays, and other
                    visual aids to enhance understanding.
                </li>
            </ul>

            <!-- Observing AMCL in Action -->
            <h3>Observing AMCL in Action</h3>
            <p>
                Through the simulation, users can observe:
            </p>
            <ul>
                <li>
                    <strong>Particle Convergence:</strong> How particles converge around the robot's true position over
                    time.
                </li>
                <li>
                    <strong>Adaptive Particle Adjustment:</strong> The dynamic increase or decrease in particle count
                    based on the robot's uncertainty.
                </li>
                <li>
                    <strong>Effect of Noise:</strong> How motion and sensor noise impact localization and how the
                    algorithm compensates for these uncertainties.
                </li>
            </ul>
            <p>
                By experimenting with different settings, users can gain a deeper understanding of the AMCL algorithm
                and its practical applications.
            </p>
        </section>

        <!-- Code Walkthrough Section -->
        <section class="mb-5">
            <h2>Code Walkthrough</h2>
            <p>
                This section provides an overview of the key components of the simulation's codebase, highlighting how
                the AMCL algorithm is implemented and optimized.
            </p>

            <!-- Structure of the Code -->
            <h3>Structure of the Code</h3>
            <p>
                The code is organized into several scripts, each responsible for different aspects of the simulation:
            </p>
            <ul>
                <li>
                    <strong>ParticleController.cs:</strong> Manages the particles, including initialization, updating,
                    weighting, and resampling.
                </li>
                <li>
                    <strong>RobotController.cs:</strong> Handles the robot's movement and sensor readings.
                </li>
                <li>
                    <strong>UIController.cs:</strong> Manages user interface elements like sliders and buttons.
                </li>
                <li>
                    <strong>Utilities.cs:</strong> Contains helper functions for mathematical calculations and random
                    number generation.
                </li>
            </ul>

            <!-- Key Functions and Classes -->
            <h3>Key Functions and Classes</h3>

            <!-- Particle Class -->
            <h4>Particle Class</h4>
            <p>
                The <strong>Particle</strong> class represents individual particles. Its attributes include:
            </p>
            <ul>
                <li>
                    <strong>Position:</strong> The particle's \( (x, y) \) coordinates in the environment.
                </li>
                <li>
                    <strong>Orientation:</strong> The particle's heading angle \( \theta \).
                </li>
                <li>
                    <strong>Weight:</strong> The particle's importance weight based on sensor measurements.
                </li>
            </ul>

            <!-- UpdateParticlePositions Function -->
            <h4>UpdateParticlePositions Function</h4>
            <p>
                This function updates the particles' positions and orientations based on the robot's movement and the
                motion model. Key aspects include:
            </p>
            <ul>
                <li>
                    <strong>Motion Update:</strong> Applies the control input \( u_t \) to each particle, adding random
                    noise to simulate motion uncertainty.
                </li>
                <li>
                    <strong>Noise Generation:</strong> Uses Gaussian distributions to generate realistic motion
                    disturbances.
                </li>
                <li>
                    <strong>Performance Optimization:</strong> Calculations are vectorized where possible to improve
                    efficiency.
                </li>
            </ul>

            <!-- CalculateWeight Function -->
            <h4>CalculateWeight Function</h4>
            <p>
                This function calculates the weight of each particle based on the likelihood of the observed sensor
                data. Key components are:
            </p>
            <ul>
                <li>
                    <strong>Sensor Simulation:</strong> Simulates sensor readings for each particle using raycasting.
                </li>
                <li>
                    <strong>Likelihood Calculation:</strong> Compares simulated readings with actual sensor data,
                    computing the probability using a Gaussian likelihood function.
                </li>
                <li>
                    <strong>Normalization:</strong> Ensures that all weights sum to one after calculations.
                </li>
            </ul>

            <!-- ResampleParticles Function -->
            <h4>ResampleParticles Function</h4>
            <p>
                This function resamples the particle set based on their weights. Notable features include:
            </p>
            <ul>
                <li>
                    <strong>Effective Sample Size (ESS):</strong> Calculates ESS to decide if resampling is necessary.
                </li>
                <li>
                    <strong>Resampling Wheel:</strong> Implements systematic resampling to select particles proportional
                    to their weights.
                </li>
                <li>
                    <strong>Adaptive Adjustment:</strong> Modifies the number of particles based on uncertainty, adding
                    or removing particles as needed.
                </li>
            </ul>

            <!-- Optimization Techniques -->
            <h3>Optimization Techniques</h3>
            <p>
                To ensure the simulation runs smoothly, especially in a web browser via WebGL, several optimization
                strategies were employed:
            </p>
            <ul>
                <li>
                    <strong>Efficient Data Structures:</strong> Used arrays and lists optimized for fast access and
                    minimal memory overhead.
                </li>
                <li>
                    <strong>Minimized Allocations:</strong> Reused objects and data structures to reduce garbage
                    collection pauses.
                </li>
                <li>
                    <strong>Mathematical Optimizations:</strong> Simplified equations and precomputed constants to
                    reduce computational load.
                </li>
                <li>
                    <strong>Conditional Updates:</strong> Limited updates and visualizations to essential frames to
                    balance performance and responsiveness.
                </li>
            </ul>

            <!-- Challenges and Solutions -->
            <h3>Challenges and Solutions</h3>
            <p>
                During development, several challenges were encountered:
            </p>
            <ul>
                <li>
                    <strong>Performance Bottlenecks:</strong> High particle counts caused frame rate drops.
                    <em>Solution:</em> Implemented adaptive particle counts and optimized critical functions.
                </li>
                <li>
                    <strong>Sample Impoverishment:</strong> Resampling could lead to loss of particle diversity.
                    <em>Solution:</em> Preserved high-weight particles and introduced partial resampling strategies.
                </li>
                <li>
                    <strong>WebGL Limitations:</strong> WebGL builds have restrictions on threading and certain
                    optimizations. <em>Solution:</em> Adjusted code to be compatible with WebGL and focused on
                    single-threaded optimizations.
                </li>
            </ul>
            <p>
                These solutions improved the simulation's reliability and user experience.
            </p>
        </section>

        <!-- Analysis and Discussion Section -->
        <section class="mb-5">
            <h2>Analysis and Discussion</h2>
            <p>
                In this section, we analyze the performance of the Adaptive Monte Carlo Localization (AMCL) algorithm as
                implemented in our simulation. We discuss the effects of various parameters, observe the behavior of the
                algorithm under different conditions, and relate our findings to the underlying principles of
                probability and statistics.
            </p>

            <!-- Performance Evaluation -->
            <h3>Performance Evaluation</h3>
            <p>
                The AMCL algorithm's effectiveness can be assessed based on its ability to accurately localize the robot
                within the environment while efficiently utilizing computational resources. Key performance metrics
                include:
            </p>
            <ul>
                <li>
                    <strong>Localization Accuracy:</strong> The proximity of the estimated robot pose to its true
                    position.
                </li>
                <li>
                    <strong>Convergence Time:</strong> The time or number of iterations required for the particles to
                    converge around the true pose.
                </li>
                <li>
                    <strong>Computational Efficiency:</strong> The processing time and resources consumed, influenced by
                    the number of particles.
                </li>
            </ul>

            <!-- Impact of Particle Count -->
            <h3>Impact of Particle Count</h3>
            <p>
                The number of particles plays a crucial role in the algorithm's performance:
            </p>
            <ul>
                <li>
                    <strong>Low Particle Count:</strong>
                    <p>
                        With too few particles, the algorithm may not adequately represent the belief distribution,
                        leading to poor localization accuracy and slow convergence. The particles might not cover the
                        entire state space, missing the true pose.
                    </p>
                </li>
                <li>
                    <strong>High Particle Count:</strong>
                    <p>
                        Increasing the number of particles improves the representation of the belief distribution,
                        enhancing accuracy and convergence speed. However, it also increases computational load,
                        potentially affecting real-time performance.
                    </p>
                </li>
            </ul>
            <p>
                AMCL addresses this by dynamically adjusting the particle count based on uncertainty, aiming for an
                optimal balance.
            </p>

            <!-- Observations from the Simulation -->
            <h3>Observations from the Simulation</h3>
            <p>
                Through the simulation, several important observations were made:
            </p>
            <ul>
                <li>
                    <strong>Convergence Behavior:</strong>
                    <p>
                        When initialized with high uncertainty, particles are spread throughout the environment. Over
                        time, as sensor data is incorporated, particles begin to converge around the true robot pose,
                        demonstrating the algorithm's ability to localize effectively.
                    </p>
                </li>
                <li>
                    <strong>Adaptive Particle Adjustment:</strong>
                    <p>
                        The simulation shows that the particle count increases when the robot encounters ambiguous areas
                        or experiences significant movement, reflecting increased uncertainty. Conversely, the particle
                        count decreases when the robot's position becomes more certain.
                    </p>
                </li>
                <li>
                    <strong>Effect of Noise:</strong>
                    <p>
                        Introducing higher levels of motion or sensor noise results in wider spread of particles and
                        slower convergence. This highlights the algorithm's sensitivity to noise and the importance of
                        accurate noise modeling.
                    </p>
                </li>
                <li>
                    <strong>Sample Impoverishment Mitigation:</strong>
                    <p>
                        Implementing strategies to preserve high-weight particles, such as partial resampling, helped
                        prevent the loss of valuable particles during resampling. This maintained particle diversity and
                        improved localization stability.
                    </p>
                </li>
            </ul>

            <!-- Relation to Probability and Statistics -->
            <h3>Relation to Probability and Statistics</h3>
            <p>
                The simulation illustrates several core concepts in probability and statistics:
            </p>
            <ul>
                <li>
                    <strong>Random Sampling:</strong>
                    <p>
                        Particles are sampled from probability distributions to represent the belief about the robot's
                        state. This stochastic process underpins the algorithm's ability to handle uncertainty.
                    </p>
                </li>
                <li>
                    <strong>Probability Distributions:</strong>
                    <p>
                        The belief is modeled as a probability distribution over the state space. The use of Gaussian
                        distributions for motion and sensor models reflects common practices in statistical modeling of
                        noise.
                    </p>
                </li>
                <li>
                    <strong>Bayesian Inference:</strong>
                    <p>
                        The algorithm continuously updates the belief based on new data, embodying Bayesian principles.
                        It combines prior knowledge with new evidence to refine estimates.
                    </p>
                </li>
                <li>
                    <strong>Effective Sample Size (ESS):</strong>
                    <p>
                        Calculating ESS demonstrates the application of statistical measures to assess the quality of
                        the particle set and inform resampling decisions.
                    </p>
                </li>
            </ul>

            <!-- Limitations and Challenges -->
            <h3>Limitations and Challenges</h3>
            <p>
                While the simulation effectively demonstrates AMCL, certain limitations and challenges were identified:
            </p>
            <ul>
                <li>
                    <strong>Computational Constraints:</strong>
                    <p>
                        High particle counts can strain computational resources, especially in a web-based environment
                        like WebGL. This necessitated optimizations and adaptive strategies to maintain performance.
                    </p>
                </li>
                <li>
                    <strong>Noise Modeling:</strong>
                    <p>
                        Accurately modeling motion and sensor noise is crucial for realistic simulation. Simplifications
                        or inaccuracies in noise parameters can affect the algorithm's behavior.
                    </p>
                </li>
                <li>
                    <strong>Environmental Complexity:</strong>
                    <p>
                        The simulation environment may not capture all complexities of real-world scenarios, such as
                        dynamic obstacles or varying terrain, limiting the applicability of findings to some extent.
                    </p>
                </li>
                <li>
                    <strong>Sample Impoverishment:</strong>
                    <p>
                        Despite mitigation efforts, sample impoverishment remains a challenge. Overcoming this requires
                        careful tuning of resampling strategies and noise parameters.
                    </p>
                </li>
            </ul>

            <!-- Future Work -->
            <h3>Future Work</h3>
            <p>
                Potential avenues for extending this project include:
            </p>
            <ul>
                <li>
                    <strong>Implementing Additional Algorithms:</strong>
                    <p>
                        Comparing AMCL with other localization algorithms, such as Extended Kalman Filters or Grid-based
                        methods, to evaluate their relative performance.
                    </p>
                </li>
                <li>
                    <strong>Enhancing the Simulation Environment:</strong>
                    <p>
                        Introducing dynamic elements, more complex maps, or multi-robot scenarios to test the algorithm
                        under varied conditions.
                    </p>
                </li>
                <li>
                    <strong>Optimizing Performance:</strong>
                    <p>
                        Exploring advanced optimization techniques, such as parallel processing or hardware
                        acceleration, to handle larger particle counts efficiently.
                    </p>
                </li>
                <li>
                    <strong>User Interface Improvements:</strong>
                    <p>
                        Adding more interactive controls, real-time analytics, or educational tools to enhance user
                        engagement and learning outcomes.
                    </p>
                </li>
            </ul>
        </section>

        <!-- Conclusion Section -->
        <section class="mb-5">
            <h2>Conclusion</h2>
            <p>
                This project provided an in-depth exploration of Adaptive Monte Carlo Localization (AMCL) and its
                application in robot localization. By developing an interactive simulation and examining the algorithm's
                theoretical foundations, we achieved several key objectives:
            </p>
            <ul>
                <li>
                    <strong>Understanding AMCL:</strong>
                    <p>
                        Gained a comprehensive understanding of how AMCL utilizes probabilistic methods to estimate a
                        robot's pose within a known environment.
                    </p>
                </li>
                <li>
                    <strong>Practical Implementation:</strong>
                    <p>
                        Successfully implemented the AMCL algorithm in a simulation, overcoming challenges related to
                        performance and accuracy.
                    </p>
                </li>
                <li>
                    <strong>Educational Value:</strong>
                    <p>
                        Created a tool that effectively demonstrates complex probabilistic concepts in an accessible and
                        interactive manner, enhancing learning for students and educators.
                    </p>
                </li>
                <li>
                    <strong>Application of Probability and Statistics:</strong>
                    <p>
                        Applied theoretical concepts from probability and statistics, such as Bayesian inference and
                        random sampling, to solve a real-world problem in robotics.
                    </p>
                </li>
            </ul>
            <p>
                The project highlights the critical role of probability and statistics in modern robotics. Localization,
                a fundamental challenge in robotics, relies heavily on these mathematical principles to handle
                uncertainty and make informed decisions based on incomplete or noisy data.
            </p>
            <p>
                Through this endeavor, we demonstrated not only the effectiveness of AMCL but also the broader
                importance of probabilistic algorithms in technology and science. The integration of theory and
                practical application serves as a valuable educational experience, reinforcing the relevance of
                statistical methods in solving complex problems.
            </p>
            <p>
                We hope that this project serves as a useful resource for those interested in robotics, localization
                algorithms, and the practical application of probability and statistics.
            </p>

            <!-- Acknowledgments (Optional) -->
            <h3>Acknowledgments</h3>
            <p>
                I would like to thank my teacher, Ivan T. Ivanov, for the valuable guidance and resources provided
                throughout this
                project.
            </p>
        </section>

        <!-- References Section -->
        <section class="mb-5">
            <h2>References</h2>
            <p>
                This section lists all the sources and materials referenced during the development of this project.
                Proper attribution ensures academic integrity and acknowledges the contributions of prior work.
            </p>
            <ul>
                <li>
                    Thrun, S., Burgard, W., & Fox, D. (2005). <em>Probabilistic Robotics</em>. The MIT Press.
                    <p>
                        A foundational textbook that covers the principles of probabilistic robotics, including Monte
                        Carlo Localization (MCL) and particle filters.
                    </p>
                </li>
                <li>
                    Dieter Fox (1999). <em>Monte Carlo Localization: Efficient Position Estimation for Mobile
                        Robots</em>. Proceedings of the National Conference on Artificial Intelligence (AAAI).
                    <p>
                        This paper introduces Monte Carlo Localization and its application to mobile robots.
                    </p>
                </li>
                <li>
                    LaValle, S. M. (2006). <em>Planning Algorithms</em>. Cambridge University Press.
                    <p>
                        A comprehensive resource on algorithms for robot planning and control, including localization
                        techniques.
                    </p>
                </li>
                <li>
                    MathWorks. (n.d.). <em>Introduction to Bayesian Statistics</em>. Retrieved from:
                    <a href="https://www.mathworks.com" target="_blank">https://www.mathworks.com</a>
                    <p>
                        An accessible guide to Bayesian inference and its applications in various fields, including
                        robotics.
                    </p>
                </li>
                <li>
                    Unity Documentation. (n.d.). <em>Unity User Manual</em>. Retrieved from:
                    <a href="https://docs.unity3d.com" target="_blank">https://docs.unity3d.com</a>
                    <p>
                        The official Unity documentation, which provided guidance on implementing the simulation
                        environment.
                    </p>
                </li>
            </ul>
            <p>
                Additional resources, such as lecture notes and online tutorials, were used to supplement these primary
                references.
            </p>
        </section>

        <!-- Appendices Section -->
        <section class="mb-5">
            <h2>Appendices</h2>
            <p>
                The appendices provide supplementary materials that support the content presented in this project. These
                materials include additional diagrams, code snippets, and calculations that were referenced or used
                during the development process.
            </p>

            <!-- Appendix A: Code Snippets -->
            <h3>Appendix A: Code Snippets</h3>
            <p>
                Below are selected code snippets that illustrate key aspects of the AMCL implementation.
            </p>
            <pre>
<code>
// Example: Particle Weight Calculation
private void CalculateWeight(float[] robotDistances) {
    float totalLogWeight = float.NegativeInfinity;
    for (int i = 0; i < particles.Count; i++) {
        float[] particleDist = GetRaycastDistances(sensorsOrigins[i]);
        float logWeight = 0;
        for (int j = 0; j < robotDistances.Length; j++) {
            float distanceError = robotDistances[j] - particleDist[j];
            logWeight += -(distanceError * distanceError) / (2 * sensorVariance * sensorVariance);
        }
        particles[i].weight = logWeight;
        totalLogWeight = LogSum(totalLogWeight, logWeight);
    }
}
</code>
    </pre>

            <!-- Appendix B: Mathematical Derivations -->
            <h3>Appendix B: Mathematical Derivations</h3>
            <p>
                The derivation of the Effective Sample Size (ESS) formula:
            </p>
            <div class="text-center">
                \( ESS = \frac{1}{\sum_{i=1}^M \left( w_t^{[i]} \right)^2 } \)
            </div>
            <p>
                Here, \( w_t^{[i]} \) represents the normalized weight of the \( i \)-th particle. The ESS quantifies
                the diversity of the particle set, with lower values indicating a higher likelihood of particle
                degeneracy.
            </p>

            <!-- Appendix C: Additional Diagrams -->
            <h3>Appendix C: Additional Diagrams</h3>
            <p>
                Below is an additional diagram illustrating the resampling step in the particle filter:
            </p>
            <div class="text-center">
                <img src="images/resampling_step.png" alt="Resampling Step Diagram"
                    style="max-width: 100%; height: auto;">
            </div>
            <p>
                This diagram shows how particles with higher weights are more likely to be selected during the
                resampling process, leading to a new set of particles that better represent the belief distribution.
            </p>

            <!-- Appendix D: Simulation Settings -->
            <h3>Appendix D: Simulation Settings</h3>
            <p>
                Default parameters used in the simulation:
            </p>
            <ul>
                <li><strong>Initial Particle Count:</strong> 300</li>
                <li><strong>Sensor Variance:</strong> 10.0</li>
                <li><strong>Position Noise Standard Deviation:</strong> 0.1</li>
                <li><strong>Orientation Noise Standard Deviation:</strong> 1.0</li>
                <li><strong>Effective Sample Size (ESS) Threshold:</strong> 0.5</li>
            </ul>
            <p>
                These settings can be adjusted through the user interface to explore their effects on localization
                accuracy and performance.
            </p>
        </section>

        <!-- Additional Sections -->
        <!-- Add more sections as needed -->
    </main>

    <!-- Footer -->
    <footer class="bg-primary text-white text-center py-3">
        <p>&copy; 2024 Sohaib Kaidali. All rights reserved.</p>
    </footer>

    <!-- Bootstrap JS and dependencies (Popper.js) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Custom JS (optional) -->
    <script src="script.js"></script>
</body>

</html>